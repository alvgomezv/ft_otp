#!/goinfre/alvgomez/miniconda3/envs/42cyber-alvgomez/bin/python
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    ft_otp                                             :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: alvgomez <alvgomez@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/04/17 17:41:59 by alvgomez          #+#    #+#              #
#    Updated: 2023/04/17 17:42:00 by alvgomez         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

import os
import argparse
import pyotp
import base64
import time
import PySimpleGUI as sg
from datetime import datetime, timezone
import hmac
import hashlib
import getpass
from cryptography.fernet import Fernet
import qrcode

def is_hex(text):
    try:
        int(text, 16)
        return True
    except ValueError:
        return False

def pyotp_value(key_given, passw):
    with open(key_given, "rb") as f:
        key = f.read()
    key_dec = decrypt_key(key, passw)
    key_b32 = (base64.b32encode(key_dec)).decode('utf-8')
    img = qrcode.make("key_b32")
    img.save('MyQRCode.png')
    totp = pyotp.TOTP(key_b32, interval=30, digits=6)
    print(f"pyotp:  {totp.now()}")

def encrypt_key(key, passw):
    fernet = Fernet(passw)
    key_enc = fernet.encrypt(key)
    return key_enc

def decrypt_key(key_enc, passw):
    fernet = Fernet(passw)
    key_dec = fernet.decrypt(key_enc)
    return key_dec

def Generate_key(passw):
    passw = passw.encode('utf-8')
    hash_passw = hashlib.sha256(passw).digest()
    passw_b64 = base64.b64encode(hash_passw)
    return passw_b64

class Otp:
    def __init__(self,args):
        self.hex_key = args.hex_key
        self.otp_key = args.otp_key

    def save_key(self):
        try:
            key = open(self.hex_key, "rb").read()
        except:
            raise Exception("Invalid Key")
        else:
            if is_hex(key) and len(key) >= 64:
                passw = Generate_key(getpass.getpass("Create your password: "))     
                key_enc = encrypt_key(key, passw)
                try:
                    with open("ft_otp.key", "wb") as otp_key:
                        otp_key.write(key_enc)
                    print("Key was successfully saved in ft_otp.key.")
                except:
                    raise Exception("Key could not be saved")
            else:
                raise Exception("Key must be 64 hexadecimal characters")

    def generate_password(self):
        passw = Generate_key(getpass.getpass("Enter your password: "))
        with open(self.otp_key, "rb") as f:
            try:
                key = f.read()
            except:
                Exception("Key not found")
            else:
                try:
                    key_dec = decrypt_key(key, passw)
                except:
                    print("Password not correct")
                    exit()
        counter = (int(time.time() / 30))
        counter_bytes = counter.to_bytes(8, byteorder="big")
        hmac_sha1 = hmac.new(key_dec, counter_bytes, hashlib.sha1).digest()
        offset = hmac_sha1[-1] & 0x0F
        otp_bytes = hmac_sha1[offset:offset+4]
        otp_int = int.from_bytes(otp_bytes, byteorder="big") + 0x7FFFFFFF
        otp_int = ((hmac_sha1[offset]  & 0x7f) << 24 |
            (hmac_sha1[offset+1] & 0xff) << 16 | 
            (hmac_sha1[offset+2] & 0xff) <<  8 | 
            (hmac_sha1[offset+3] & 0xff))
        otp = otp_int % (10 ** 6)
        print(f"ft_otp: {otp:06d}")
        return passw


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("-g", type=str, action="store", dest="hex_key", help="Store key of at lear 64 characters")
    parser.add_argument("-k", type=str, action="store", dest="otp_key", help="Generate new temporary password and print it")
    arg = parser.parse_args()
    return arg

if __name__ == "__main__":
    args = parse_arguments()
    otp = Otp(args)
    if otp.hex_key:
        otp.save_key()
    if otp.otp_key:
        passw = otp.generate_password()
        pyotp_value(otp.otp_key, passw)

    
    

    

